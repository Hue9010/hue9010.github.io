---
layout: post
title:  "브라우저의 작동 원리"
tags: [프론트엔드, 브라우저]
categories: [etc]
description: "브라우저의 렌더링 엔진의 작동 원리를 알아보자"
---

브라우저의 작동 원리  
=================  

![브라우저_구조](/images/browser/브라우저_구조.png)  

- 사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분  

- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어  

- 자료 저장소 : 자료를 저장하는 계층. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.  

- 렌더링 엔진 : 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시  

- 통신 : HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행  

- 자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행  

- UI 백엔드 : 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용  

---  

렌더링 엔진  
==========  

- 익스플로러 : Trident  
- 파이어폭스 : Gecko  
- 크롬 : Webkit(27버전 이하), Blink(28버전 이상)  
- 사파리 : Webkit  
- 오페라 : Presto(14버전 이하), Blink(15버전 이상)  

Webkit, Gecko 같은 경우는 오픈소스  

---  

렌더링 과정  
==========  

![랜더링_과정](/images/browser/랜더링_과정.png)  

앞으로 많이 보게 될 그림으로 렌더링 엔진으 렌더링을 하는 과정 입니다.  

- HTML 파싱 : HTML 문서를 읽어 DOM 트리를 구축 하는 단계입니다. 평소 하는 DOM 조작이 여기서 만들어진 DOM을 조작 하는 것이죠.(말 그대로 DOM을 조작 하는 것이지 HTML 문서를 조작 하는게 아닙니다.)  

- 랜더 트리 구축 :  HTML 파싱을 통해 만들어진 DOM 트리와 이후 설명할 CSSOM(DOM 트리와 같은 CSS 판 DOM 트리)를 통해 DOM 트리에 생긴 노드들에 대한 스타일을 매핑 시킨 트리입니다.  

- 랜더 트리 배치 : 랜더 트리 내에는 노드에 대한 정보와 스타일에 대한 정보만 가지고 있을 뿐 화면 어느 곳에 위치 할 지에 대한 정보는 없는데 위치 정보를 계산 하는 단계입니다.  

- 랜더 트리 그리기 : 계산 된 위치 정보를 가지고 실제 사용자 브라우저에 화면을 출력 해주는 단계 입니다.  

자세한 설명은 각각의 단계 때 진행 하도록 하겠습니다.  

---  

Webkit의 렌더링 과정  
==================  

설명에 들어가기 앞서 렌더링 엔진의 하나인 웹킷 기반으로 설명을 할 것이라 웹킷의 렌더링 과정을 보도록 하겠습니다.  

![webkit](/images/browser/webkit.png)  

![랜더링_과정](/images/browser/랜더링_과정.png)  

뭔가 많이 복잡 해 보이지만

- DOM 트리 구축 위한 HTML 파싱 : HTML 파서, DOM 트리  

- 렌더 트리 구축 : 어테치먼트, 렌더트리  

- 렌더 트리 배치 : 배치  

- 렌더 트리 그리기 : 그리기  

DOM 트리를 구축 하는 부분이 좀 더 세분화 되었고 HTML만이 아니라 스타일 시트에 대한 작업이 추가 되었다는 점만 다르지 기본적인 렌더링 엔진이랑 유사하다는 걸 알 수 있습니다.  

이제 첫 단계인 HTML을 파싱 하여 DOM 트리를 생성 하는 부분을 보도록 하겠습니다.  

---  

DOM 트리 구축 위한 HTML 파싱  
=========================  

![full-process](/images/browser/full-process.png)  

HTML을 파싱 하여 DOM 트리를 생성 하는 과정은

1. **변환:** 브라우저가 HTML의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩(예: UTF-8)에 따라 개별 문자로 변환합니다.  

2. **토큰화:** 브라우저가 문자열을 W3C HTML5 표준에 지정된 고유 토큰으로 변환합니다(예: '<html>', '<body>' 및 꺽쇠괄호로 묶인 기타 문자열). 각 토큰은 특별한 의미와 고유한 규칙을 가집니다.  

3. **렉싱:** 방출된 토큰은 해당 속성 및 규칙을 정의하는 '객체'로 변환됩니다.  

4. **DOM 생성:** 마지막으로, HTML 마크업이 여러 태그(일부 태그는 다른 태그 안에 포함되어 있음) 간의 관계를 정의하기 때문에 생성된 객체는 트리 데이터 구조 내에 연결됩니다. 이 트리 데이터 구조에는 원래 마크업에 정의된 상위-하위 관계도 포합됩니다. 즉, HTML 객체는 body 객체의 상위이고, body 는 paragraph 객체의 상위인 식입니다.  

이와 같은 과정을 거칩니다만, HTML 문서를 읽어 가장 밑에 있는 DOM 트리가 생성 된다는 점만 확실히 기억 하시는 것이 가장 중요합니다.  

좀더 익숙한 형태로 HTML문서가 어떻게 DOM 트리가 되나 보도록 하죠.  


```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![dom-tree](/images/browser/dom-tree.png)  

HTML의 모든 요소가 DOM트리에 포함 된 것을 볼 수 있습니다.  

**이 전체 프로세스의 최종 출력이 바로 DOM(Document Object Model)이며, 브라우저는 이후 모든 페이지 처리에 이 DOM을 사용합니다.**  

자바스크립트를 통해 조작하는 것도 어디까지나 DOM이지 HTML이 아니라는 점입니다. 평소 사용하는 말도 DOM 조작이라고 하지 HTML 조작이라고 하지 않는 이유가 여기 있는 것이지요.  

![DOM_트리_생성](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-timeline.png?hl=ko)  
(크롬 브라우저 개발자 도구의 performance에서 해당 과정을 확인 할 수 있습니다. [좀더 알아보기](https://developers.google.com/web/tools/chrome-devtools/?hl=ko))  

여기까지가 HTML문서를 파싱하여 DOM 트리를 만드는 과정 이였습니다.  

다만, DOM 트리는 문서 마크업의 속성 및 관계를 포함하지만 요소가 렌더링될 때 어떻게 표시될지에 대해서는 알려주지 않습니다. 이것은 CSSOM의 책임입니다. CSSOM은 조금 있다가 설명 드리도록 하겠습니다.  

---

## 브라우저의 오류 처리  

추가적으로 HTML 페이지에서 "유효하지 않은 구문" 이라는 오류를 본 적이 없을 겁니다. 이는 브라우저가 모든 오류 구문을 교정하기 때문입니다. 아래 오류가 포함된 HTML 예제를 보죠.  

```html
<html>  
   <mytag></mytag>
   <div>
     <p>
   </div>
   Really lousy HTML
   </p>
</html>  
```  

HTML에는 존재하지 않는 `mytag`라던지 잘못 중첩된 `p`, `div`태그가 존재 해도 파서가 HTML 제작자의 실수를 수정 해줍니다.  

```html  
<table>
    <table>
        <tr>
            <td>inner table</td>
        </tr>
    </table>
    <tr>
        <td>outer table</td>
    </tr>
</table>
```  

브라우저는 HTML 문서를 파싱 하다가 테이블 안에 테이블이 있으면  

```html  
<table>
    <tr>
        <td>outer table</td>
    </tr>
</table>
<table>
    <tr>
        <td>inner table</td>
    </tr>
</table>
```  

자동적으로 HTML 문법에 맞게 테이블을 수정 해줍니다.  

이에 대해서는 HTML 명세에 따로 존재 하지 않아도 다른 브라우저들이 그러했듯이 관습적으로 오류를 고쳐주고 있습니다.  

HTML5 명세는 이런 요구 사항 일부를 정의했습니다. 웹킷은 이것을 HTML 파서 클래스의 시작 부분에 주석으로 잘 요약해 두었답니다.  

> 파서는 토큰화된 입력 값을 파싱하여 문서를 만들고 문서 트리를 생성한다. 규칙에 맞게 잘 작성된 문서라면 파싱이 수월하겠지만 불행하게도 형식에 맞지 않게 작성된 많은 HTML 문서를 다뤄야 하기 때문에 파서는 오류에 대한 아량이 있어야 한다.  
>  
> 파서는 적어도 다음과 같은 오류를 처리해야 한다.  
>  
> 1. 어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.  
> 2. 파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.  
> 3. 인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.  
> 4. 이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.  


---  

잠시 웹킷과 게코의 렌더링 엔진을 비교해 보도록 하겠습니다.  

### Webkit  

![webkit](/images/browser/webkit.png)  

### Gecko  

![gecko](/images/browser/gecko.png)  

웹킷과 게코의 렌더링 엔진의 동작 과정인데 특정 용어들이 조금 다르지만 기본적으로 동일하다는 것을 알 수 있습니다.  

게코에는 콘텐츠 싱크라는 과정이 추가적으로 존재 하지만 웹킷과 비교하여 의미있는 차이점이라고 보지는 않습니다.  

지금까지는 웹킷 기준으로 **DOM 트리**를 생성 하는 부분까지 설명을 하였는데 이제는 어테치먼트가 일어나기 전 스타일 시트에서 CSSOM을 만든 과정을 보도록 하겠습니다.  

---

## CSSOM(CSS Object Model)  

브라우저가 DOM을 생성하는 동안 CSS 스타일시트를 만나면 DOM 트리를 만드는 것 처럼 스타일 파일을 파싱 하여 CSSOM이라는 트리 구조로 정보를 가집니다.  

트리 구조를 가지는 이유에 대해서는 cascade 때문이라는 언급들이 많은데, 부모의 스타일을 자식 들한테 상속 시키기 쉽다는 이점을 가집니다. (예: body 요소의 하위인 경우 모든 body 스타일 적용)  

```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

![cssom-construction](/images/browser/cssom-construction.png)  
![cssom-tree](/images/browser/cssom-tree.png)  

또한, 위의 트리는 완전한 CSSOM 트리가 아니고 스타일시트에서 재정의하도록 결정한 스타일만 표시합니다. 모든 브라우저는 '사용자 에이전트 스타일'이라고 하는 기본 스타일 집합, 즉 개발자가 고유한 스타일을 제공하지 않을 경우 표시되는 스타일을 제공합니다. 개발자가 작성하는 스타일은 이러한 기본 스타일을 간단하게 재정의합니다.  

### 스타일 적용 순서  
  1. 브라우저 선언 (browser declarations)  

  2. 사용자 일반 선언 (user normal declarations)  

  3. 저작자 일반 선언 (author normal declarations)  

  4. 저작자 중요 선언 (author important declarations)  

  5. 사용자 중요 선언 (user important declarations)  

밑(5번)으로 갈 수록 우선순위가 높습니다.  

![CSSOM_생성](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-timeline.png?hl=ko)  

DOM 파싱과 달리, 타임라인에 'Parse CSS' 항목이 별도로 표시되지 않으며, 대신 파싱 및 CSSOM 트리 생성과 계산된 스타일의 재귀적 계산이 'Recalculate Style' 이벤트에서 캡처됩니다.

---  

렌더 트리  
========  

![render-tree-construction](/images/browser/render-tree-construction.png)  

브라우저가 위에서 만든 DOM 트리와 CCSOM을 `렌더 트리`에 결합합니다. 이 트리는 페이지에 표시되는 모든 DOM 콘텐츠와 각 노드에 대한 모든 CSSOM 스타일 정보를 가지고 있습니다.  

렌더 트리를 생성하려면 브라우저가 대략적으로 다음 작업을 수행합니다.  

1. DOM 트리의 루트에서 시작하여 표시되는 노드 각각을 순회합니다.  
    - 일부 노드는 표시되지 않으며(예: 스크립트 태그, 메타 태그 등), 렌더링된 출력에 반영되지 않으므로 생략됩니다.  

    - 일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생략됩니다. 예를 들어, 위의 예시에서 span 노드의 경우 'display: none' 속성을 설정하는 명시적 규칙이 있기 때문에 렌더링 트리에서 누락됩니다.  

2. 표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용합니다.  

3. 표시된 노드를 콘텐츠 및 계산된 스타일과 함께 내보냅니다.  

1번의 세부사항에서와 같이 화면에 보일 요소에 대해서만 렌더 트리 내의 요소로 포함 하기 때문에 CSSOM의 'display: none'요소와 DOM 트리 내의 'meta', 'link' 태그와 같은 요소는 포함이 되지 않습니다.  

다만, visibility: hidden은 display: none과 다릅니다. 전자는 요소를 보이지 않게 만들지만, 이 요소는 여전히 레이아웃에서 공간을 차지합니다(즉, 비어 있는 상자로 렌더링됨). 반면, 후자(display: none)는 요소가 보이지 않으며 레이아웃에 포함되지도 않도록 렌더 트리에서 요소를 완전히 제거합니다.  

즉, 렌더 트리는 **화면에 표시되는** 모든 노드의 콘텐츠 및 스타일 정보를 모두 포함하는 트리입니다. 렌더 트리가 생성되었으므로 '배치(layout)' 단계로 진행할 수 있습니다.

---  

배치(layout) & 그리기(paint)  
==========================  


---  

![nytimes-css-device](/images/browser/nytimes-css-device.png)  

![nytimes-nocss-device](/images/browser/nytimes-nocss-device.png)  

---  

자바스크립트  



![script](/images/browser/script.png)  

```html
<script async src=”script.js”>  
```  

![script_async](/images/browser/script_async.png)  

```html
<script defer src=”script.js”>
```  

![script_defer](/images/browser/script_defer.png)  

---  

레이어  

![layers](/images/browser/layers.jpg)  

![0_bPhQz5ma5Y8jVpd3](/images/browser/0_bPhQz5ma5Y8jVpd3.png)  

---

참조  
====  

https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko  

https://d2.naver.com/helloworld/59361  
