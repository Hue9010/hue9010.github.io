---
layout: post
title:  "temp"
tags: [리눅스, 우분투]
categories: [etc]
description: "분류에 상관 없이 한 두번씩 눈에 보인다던지, 알아두고자 하는 용어들이 보이면 추가 하고 설명을 적어보자."
---

## 표현식(expression) 문(statement)

표현식 : 결과가 값  
"당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다."  
조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시 했을 뿐.

문 : 일종의 지시  
"볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요."  
지시를 받았고, 그 결과를 반환 해야 한다.  

```js  
let x;  // 선언문  
x = 3 * 5;  // 곱셈 표현식 + 할당 표현식  
```

표현식과 문 둘다 무언가를 한다. 하지만 그 결과를 명시적으로 반환하는 것은 표현식이다.

포현식은 값이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다.  

---

##  문의 완료 값  

모든 문은 완료 값을 가지며 문의 완료 값을 보고한다.

```js
var b;  
// undefined

if (true) {
  b = 4 + 38;
}
// 42
```  
블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환  

```js
var a, b;
a = if (ture) {
  b = 4 + 38;
}
```

```js
var a, b;
a = eval( "if (true) { b = 4 + 38; }" );
a; // 42
```

```js
var a, b;
a = do {
  if ( true) {
    b = 4 + 38;
  }
};
a; // 42
```  
### do {} 표현식 (ES7) :  
  - 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환.  
  - 문을 표현식처럼 다루자는 게 기본적인 아이디어  

---

## 표현식의 부수 효과  

```js  
function foo() {
  a = a + 1;
}

var a = 1;
foo();  // 결과ㄱ밧: 'undefined', 부수 효과 : 'a'가 변경됨
```  

```js
var a = 42;
var b = a++;
```

```js
var a = 42;
a++;  // 42
a;

++a;  // 44
a;  // 44
```
전위 : 값이 반환되기 전  
후위 : 값이 반환 된 이후  

---

## 콤마 연산자  

다수의 개별 표현식을 하나의 문으로 연결  

```js
var a = 42, b;
b = ( a++, a);

a;  // 43
b;  // 43
```  

```js

if( a > 3 ){
  b = 5;
  c = 4;
  arr.push( b );
}else{
  b = 1;
  error();
}

a > 3 ? b = 5, c = 4, arr.push( b ) : b = 1, error() ;
```  

```js
var obj = {
  a: 42
};

obj.a;  //42
delete obj.a; //true
obj.a;  //undefined
```

---

### delete :
- 결과값이 유효한/허용된 연산일 경우 true, 그외엔 false  
- 프로퍼티(또는 배열 슬롯)을 제거하는 부수효과  


```js
var a;
a = 42;
a;
```
42를 a에 할당하는 자체가 본질적으로 부수 효과다.  

```js
var a, b, c;
a = b = c = 42;
```  

---

```js
function vowels(str) {
  var matches;
  if(str) {
    // 모든 몽므을 추출한다.
    matches = str.match( /[aeiou]/g );
    if (matches) {
      return matches;
    }
  }
}
vowels ("Hello World" ); // ["e", "o", "o"]
```

```js
function vowels(str) {
  var matches;
  // 모든 모음을 추출한다.
  if(str && (matches = str.match( /[aeiou]/g ))) {
    return matches;
  }
}
vowels ("Hello World" ); // ["e", "o", "o"]
```

---

## 콘텍스트 규칙  

### 객체 리터럴  
```js
// bar() 함수는 앞에서 정의되어있다.

var a = {
  foo: bar()
};
```
{}는 a에 할당 될 값이므로 객체 리터럴  

a : R-value  
{} : L-value  

---

### 레이블  
```js
// bar() 함수는 앞에서 정의되어 있다.
{
  foo: bar()
}
```  
{} 코드 블록은 for/while 루프, if 조건 등에 붙어있는 코드 블록과 기능적으로 매우 유사  

---

## 레이블 점프 : goto문

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// whenever the loops meet, continue outer loop
		if (j == i) {
			// jump to the next iteration of
			// the `foo` labeled-loop
			continue foo;
		}

		// skip odd multiples
		if ((j * i) % 2 == 1) {
			// foo라는 레이블이 붙은 루프의 다음 순회를 계속하라
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
```


---

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "stopping!", i, j );
			// foo라는 레이블이 붙은 바깥쪽 루프/블록 밖으로 나가 그 이후부터 계속하라
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// stopping! 1 3
```
---

### 비루프 블록

```js
function foo() {
	// `bar` labeled-block
	bar: {
		console.log( "Hello" );
		break bar;
		console.log( "never runs" );
	}
	console.log( "World" );
}

foo();
// Hello
// World
```

비 루프 블록에선 continue 밑 레이블이 없는 break으로 블록을 빠져나가는 건 안 된다.  

---

### 블록  

```js
[] + {};// "[object Object]"
{} + []; // 0
```

**윗 줄** : {}를 실제 값(빈 객체로) 해석, []는 ""로 강제변환, {}도 문자열 "[object Object]"로 강제변환  

**아랫 줄** : {}는 빈 블록으로 간주, [] 숫자 0으로 강제 변환  

---

### 객체 분해  

ES6부터는 분해 할당(Destructuring Assignments), 구체적으로는 객체 분해 시 {}를 사용한다.  

```js
function getData() {
	// ..
	return {
		a: 42,
		b: "foo"
	};
}

var { a, b } = getData();

console.log( a, b ); // 42 "foo"
```  

```js
var res = getData();
var a = res.a;
var b = res.b;
```

---

{}를 이용한 객체 분해를 명명된 함수에 활용  

```js
function foo({ a, b, c }) {
	// no need for:
	// var a = obj.a, b = obj.b, c = obj.c
	console.log( a, b, c );
}

foo( {
	c: [1,2,3],
	a: 42,
	b: "foo"
} );	// 42 "foo" [1, 2, 3]
```

{}은 전적으로 사용 콘텍스트에 따라 의미가 결정 된다.  

---

else if와 선택적 블록  
