---
layout: post
title:  "171130-TIL"
tags: [2017, TIL]
categories: TIL
description: "캐시 및 HTTPS, HTTP2.0 Q&A, 헤드퍼스트 Servlet & JSP 공부"
---

오늘 한일
========

### - 캐시 및 HTTPS, HTTP2.0 Q&A

  - 캐시 부분은 가볍게 봐서 놓쳤던 부분들을 보충 하게 됨  

  - 캐시된 응답 무효화 및 업데이트를 하는 방법 및 적용 사례를 봄

    - 쿠팡의 경우 캐싱될 자원의 path에 빌드 날짜를 추가하여 업데이트가 있을시 날짜에 의해 자동으로 path가 변경되어 클라이언트에서 새로 받게 된다.  

  - 구글 검색의 이미지 탭에 이미지들을 빠르게 처리하기 위한 방법을 알게됨(base64 인코딩, 네이버의 경우 확인해 보니 각각의 img src가 박혀있다)  

  - 예전 네이버의 경우 로그인 부분만 Https로 구현되어 있었는데, 그게 어떻게 가능한지 알게됨.(iframe)  

  - node.js의 경우 하나의 쓰레드(1mb) 여러개의 소켓(1kb)을 가지고 반복문 도는 방식, 자바의 경우 요청에 따른 여러 쓰레드, 그에 따른 여러 소켓 사용.  

  - 쓰레드 풀로 지나치게 많은 쓰레드를 생성 하면 메모리가 꽉차서 서버가 죽을 수 있다. 사용자 입장에선 느린것 보다 안되는게 더 최악이다.(톰캣 기본 설정은 200개)  
    ```xml
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="10000"
               redirectPort="8443"  
               maxThreads="400"   
               acceptCount ="150" />
    ```  

    acceptCount를 통해 쓰레드가 모두 사용 중일 경우 Request Queue에 쌓이는 대기 요청의 수를 조정 할 수 있다.  

  - HTTP2.0이라고 무조건 빠르진 않다. 이론상으론 더 빨라야 하는데 말이다...https를 적용해서 개발하는게 생각보다 간단하다(무료 인증서도 받을수 있고) 그러니 가능하면 https로 개발 해보자.

### - 헤드퍼스트 Servlet & JSP 공부  

---

오늘 느낀점
==========

- 사실 캐시 부분은 링크 되어 있던 캐시 [HTTP 캐싱](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching) 페이지만 보고 가볍게 질답 시간을 가졌다. 캐시 보존 기간 설정 및 기간이 남은 캐시 데이터를 업데이트 하기 위해 URL을 변경한다는 점과 캐시를 통해 불필요한 데이터 전송을 줄인다는 점 정도만 생각하고 더 깊게 생각해 보진 않았다. 그러다가 오늘 설명을 들으면서 아차 싶었다. 솔직히 캐시를 너무 만만히, 가볍게 생각 했던거 같다.  

- 방금 TIL 작성하다 깨달았는데 내가 HTTPS와 HTTP2.0를 좀 혼동하고 있었다. HTTPS가 HTTP2.0에 포함된 내용인줄 알았다. 그 당연한 사실을 깨달은 것 만으로도 스스로 헷갈렸던 내용들이 많이 해소 됐다. 생각해보면 오늘 오전에 이상한 질문들을 많이 했던거 같다.(지금보면 웹소켓과 https의 관계를 헷갈려 할 필요조차 없다)  

  >흔히 TLS와 HTTPS를 혼동하는 경우가 많은데, 둘은 유사하긴 하지만 엄연히 다른 개념임을 알아두자. TLS는 다양한 종류의 보안 통신을 하기 위한 프로토콜이며, HTTPS는 TLS 위에 HTTP 프로토콜을 얹어 보안된 HTTP 통신을 하는 프로토콜이다. 다시 말해 TLS는 HTTP뿐만이 아니라 FTP, SMTP와 같은 여타 프로토콜까지 포함하며, HTTPS는 TLS와 HTTP가 조합된 프로토콜만을 가리킨다. ([출처](https://namu.wiki/w/TLS))

  자꾸 해당 내용이 찝찝해서 다시 찾아봤는데 이제 더 명확해 졌다. 주말에 HTTPS와 HTTP2.0에 대해서 다시 확인 해보면서 정리해봐야 겠다.

- HTTPS에서 가장 혼란스러웠던 내용은 바이너리 프레이밍 계층이라는 새로운 계층이 생긴 덕분에 기존 방식과 달리 tcp -> http 사이에 캡슐화가 추가적으로 일어나니까 당연히 https를 사용하여 통신을 하게되면 다른 모든 페이지 또한 https여야 한다. 일반적으로 아주 당연하다. 근데 이전 네이버의 경우 아니였다. 로그인 페이지만 https이고 나머지 페이지는 http였다. 이 부분에 대해서 혼란을 겪었는데 포비 덕분에 해결 되었다.(당시엔 로그인 페이지만 iframe을 통한 https로 구현된 또 다른 페이지)  

- ssl의 핵심인 공개/개인키를 통한 대칭키 암호화/복호화 + 인증서 잊지말자. 도난당한 패스워드라는 책 괜찮은것 같다.  

- 이번 학습을 통해서 6월 혹은 7월에 생활코딩 페이지를 접속 하려고 하면 "해당 사이트는 인증서가 만료되었습니다."라는 문구를 보고 "해킹당했나? 뭐지?"라고 생각하면서 찝찝해서(알다시피 빨간색이 포함된 페이지가 뜬다) 이삼주 동안은 생활코딩에 접속을 안했는데 오늘 생각해보니 참....(내 개인정보가 중국 사이트에서 돌아다니는걸 본적이 있어서 내 정보는 이미 공공재라는 생각과 추가적으로 정보 유출이 될수도 있는 일엔 민감하다)

- 사실 https로 개발 하는게 엄청난 일이라고 생각 했는데(자료들을 찾아보면서는 다들 생각보다 간단하다고들 하긴 했지만) 구현할때 필요한 부분들에 대해서 좀 더 자세히 포비한테 듣게 되면서 생각보다 더 간단할 것 같다는 생각이 들었다. 트렐로를 구현할때 한번 적용해 봐야 겠다.  

- 확실히 Http 웹 서버를 구현 하면서 request, response, controller를 구현 해본 경험 덕분에 Servlet을 공부 하면서 일반적이라면 추상적으로 이해됐을 부분들이 좀 더 구체적으로 이해가 되게 되었다.   

  ```java
  PrintWriter out = response.getWriter();
  out.println("<h1>Hello world!!</h1>");
  ```
  직접적으로 중요한 부분은 아닐수도 있겠지만, 서블릿에서 이렇게 out.println을 할 시에 어떻게 이 부분을 클라이언트가 html로 받을 수 있는지도 간단히 생각 할 수 있게 되었다.(당시 HttpResponse 클래스에 out 스트림이 있는게 별로인거 같다고 했던지라 이 부분을 다시 봤을때 뜨끔 했다)  
  예시를 정작 중요한 부분을 들진 않았지만 이런 사소한 부분도 몇몇 군대 눈에 띄고, 당연히 더 핵심인 서블릿에서 전에 내가 구현한 리퀘스트, 리스폰스, 컨트롤러가 실질적으로 어떻게 구현 되었고 사용되는지 자연스럽게 이해가 된다. 한 템포 느리게 잠깐 학습의 시간을 가지는게 많은 도움이 되는거 같다.  

---

내일 할일
=========

- 헤드퍼스트 Servlet & JSP 공부 마무리

- 톰캣 완벽분석 혹은 네트워크 책 보기
