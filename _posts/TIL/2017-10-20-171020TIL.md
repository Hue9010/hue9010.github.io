---
layout: post
title:  "171020-TIL"
tags: [2017, TIL]
categories: TIL
description: "볼링 리팩토링 작업 및 Stream 연습"
---

오늘 한일
========

- 볼링 진행 사항

  - 포비의 볼링 코드 일부를 봤다. 확실히 깔끔 했다. 상속과 인터페이스를 이용 하는 법에서 배웠다.  

- 라즈베리파이 + 슬랙 봇을 이용한 출입문 제어 장치를 만들어 봤다.

오늘 느낀점
=========

- 포비의 코드들이 확실히 깔끔하고 의미도 명확했다. 클래스를 쪼갠다하면 지금까지의 접근법은 쪼갤 필요성이 있는 클래스에서 지나치게 많은 기능을 위해 코드량이 길어지는 부분이 있으면 해당 기능을 담당하는 클래스를 만들어가는 식 위주로 생가했다. 이번 볼링에서의 경우라면 Frame 클래스에 점수 계산을 대신 해줄 유틸클래스를 만들까 생각했었다. 다시 작업하는 볼링에서 점수 구현 부분까지 가면 어떻게 될지 모르겠지만, 지금 봐서는 확실히 더 깔끔해질거 같다. 조건문으로 분기하는 부분들이 상속과 인터페이스 덕에 많은 간소화가 이루어 질거 같다. 인터페이스 상속에 익숙해 지자.

- 포비의 코드를 자꾸 보면 너무 따라 할까봐 가능하면 안 볼려고하는데 계속 보게 된다. 다시 생각해보니 아직 상속과 인터페이스는 익숙하지 않으니 일단은 해당 부분을 구현하는 곳만은 따라 사용해보면서 익숙 해지는게 나을 것 같다.

- 코드를 보다가  
  ```java
  public class Frame {
    private Frame next;
    public Frame bowl(int countOfPin) {
  		state = state.bowl(countOfPin);
  		if (state.isEnd()) {
  			next = new Frame(no + 1);
  			return next;
  		}
  		return this;
  	}
  }
  ```  
  Frame이 다음 Frame이 갖는데 왜 next를 반환 할까 의문이 들었다. 심지어 isEnd()로 이 Frame이 입력이 끝난 Frame인지 확인도 안하고 점수를 넣고 본다. 처음엔 뭔가 잘못 짰나 싶었다. 그러다 다시 생각해보니 값을 입력하고 새로 생성된 state를 통해서 입력이 끝난 Frame인지 확인하고 다음 Frame을 생성하고 반환해주는 코드인거 같다. 즉, Player가 시작 Frame과 자신이 값을 입력받아야 할 Frame을 가지고 있는 구조로 설계한거 같다. 이전에 내 코드는 Frame을 순회하면 isEnd()를 확인하며 값을 입력받을 Frame을 찾아 다녔는데 이게 더 좋을 거 같다. 이건 적용해야겠다.

- Stream을 사용하다보니 이전보다 확실히 익숙해진거 같다. 거기다 Stream을 적용 할만한 곳에 잘 사용하면 코드 작성이 더 쉬워질거 같다. 그래서 지금 진행 중인 과제에서도 적용할까 싶지만, 그러다 꼬일까봐 일단은 그러지 말고 간단한 알고리즘을 풀때는 반복적으로 Stream을 이용해보면서 Stream 사용자체에 더 익숙해지고 사용 가능한 곳을 발견 하는 눈을 기르자.

- 라즈베리파이가 참 가지고 놀기 좋은거 같다. 오늘도 덕분에 기분 전환도 된거 같다. 덤으로 자바 + 백엔드에만 집중하고 거기에 크게 관련되지 않는 분야는 관심을 안가지고 있었는데 이번에 슬랙봇을 만들면서 재밌게 놀았다. 근데 재미용에다 짧은 시간에 만든거라 동작원리의 고려 없이 라이브러리만 찾아 필요한 부분만 수정해서 만들었는데 작동원리들을 물어 볼 줄이야..

내일 할일
=========

- 콘솔 볼링 게임 리팩토링

- 우아한형제들 코딩 테스트
